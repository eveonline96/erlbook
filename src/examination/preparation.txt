1、求hd(tl(tl([1,2,3,4,5,6])))的值。（答案：3）
解析：tl/1 获取列表 List1 除去第一个元素之外的尾列表。如果列表是一个空列表 []，那么则返回一个原子 badarg。
hd/1 返回一个列表 List 的第一个元素，如果列表是一个空列表，则返回 badarg。


2、[1, 4, 9] = [X * X || X <- [1,2,3,4,5], _*_]，该表达式成立的条件是什么？（答案：X =< 4）


3、[1, 3, 5] = [X || X <- [1,2,3,4,5,6], _*_]，该表达式成立的条件是什么？（答案：X rem 2 =:= 1）

4、实现keytake(Key, N, TupleList1) -> {value, Tuple, TupleList2} | false（10分）。

从元组列表 TupleList 里查找元组的第 N 个值跟 Key 是一样的元素，如果找到这个元素，则把这个元素从列表里提取出来，最后返回被提取的元素和提取后的元组列表

5.遇见一个receive表达式，从信箱中取出一条消息(队列中的第一条消息)，
拿消息跟receive表达式中的第一个子句进行模式匹配，
如果匹配成功，则绑定变量，执行与该子句关联的表达式，匹配结束，并将消息从信箱中删除。
如果匹配失败，则拿该消息与receive中的第二个子句进行匹配，直到所有模式都匹配完毕。
这个过程中如果有一个子句匹配成功，则执行与该子句关联的表达式，匹配结束，并将消息从信箱中删除；
如果所有匹配都失败，那么该消息仍旧放回队列(原来的位置上)，取出信箱中的第二条消息，再依次与receive表达式中的子句进行匹配。
如果队列中的所有消息都匹配过了（有些匹配成功的已经从队列中删除，匹配失败的仍保留在队列中），此时不管队列中还有没有消息，
Erlang进程都会阻塞住，直到队列中有新的消息到来，进程被唤醒，上述流程继续


9、求[{X, Y} || X <- [1, 2, 3], Y <- [1, 2, 3], X >= Y]的值。
（答：[{1,1},{2,1},{2,2},{3,1},{3,2},{3,3}]）



1 == 1.0 的返回值是(true )
1 =:= 1.0 的返回值是(false )
1 /= 1.0 的返回值是(false )
1 =/= 1.0 的返回值是(true )
(0 == 0) or (1/0 > 2) 的返回值是( )
(0 == 0) orelse (1/0 > 2) 的返回值是( )
true or ok 的返回值是(** exception error: bad argument
                      in operator  or/2
                         called as true or ok)
true orelse ok 的返回值是(true )
true and ok 的返回值是(* exception error: bad argument
                       in operator  and/2
                          called as true and ok )
true andalso ok 的返回值是( ok)
true andalso ok andalso false 的返回值是(** exception error: bad argument: ok )
true andalso true andalso ok 的返回值是(ok )
1 div 2 的返回值是(0 )
1 rem 2 的返回值是(1 )
1 / 1 的返回值是(1.0 )
not (1 > 2) 的返回值是(true )
11 xor10 的返回值是(* 2: syntax error before: xor10 )
true xor true 的返回值是(false )
2#11 bor 2#10 的返回值是(3 )
2#11 band 2#10 的返回值是( )
2#10 bxor 2#10 的返回值是( )
bnot 2#10 的返回值是( )
2#10 bsl 1 的返回值是(4 )
2#10 bsr 1 的返回值是(1 )




Erlang虚拟机很像一个运行了操作系统的计算机。erl对应的是BIOS，加载对应bootloader的erlexec。
erlexec加载BEAM虚拟机，BEAM虚拟机对应了操作系统。接下来BEAM进行初步的初始化，初始化执行环境，对应了操作系统的初始化。
初始化完成之后，BEAM像Linux一样加载系统中的第一个进程init。init进程读取启动列表，执行启动系统的步骤。
执行完这些步骤之后，Erlang成为了一个完全完成了初始化过程可以运行的系统。
Erlang像操作系统一样，有自己的调度系统，内存管理系统，还有和外界交互的I/O系统。
只不过内存管理系统更加的智能，可以主动帮助进程进行垃圾回收。
I/O系统以系统服务的方式存在，通过Erlang消息通信的方式向其他进程提供服务，因此Erlang的进程只需要通过消息这一种语义就能和外界交换数据。
Erlang中的模块就好像操作系统中的动态共享库，只要加载到系统中，就可以供所有的进程访问。多个模块可以组织为应用程序。
Erlang的模块命名是平坦的，因此不同应用程序中的模块不能重名。
Erlang的应用程序是对模块和进程的一种组织方式，从一个应用程序可以包含一组进程的角度看，Erlang的应用程序有点类似于Linux系统中的进程。




http://blog.yufeng.info/archives/2977
高性能网络服务器通常会涉及大量和时间相关的场景和操作，比如定时器，读取事件的发生时间，日志等等。
erlang提供了二种方式来获取时间：
1. erlang:now()
2. os:timestamp()
获取取到时间后，我们通常用calendar:now_to_universal_time来格式化类似”{{2013,11,4},{8,46,20}}”这样人可读的时间。

erlang:now在获取时间的时候需要上erts_timeofday_mtx锁，而os:timestamp则简单的调用sys_gettimeofday函数来获取，
并且在linux下gettimeofday这个系统调用由于使用频度非常高，系统已经将之vdso化了，也就说去取这个时间等同于读取一个字长的内存的代价而已。

我们的proxy服务器会在各个点调用时间函数，同时我们的函数是多个调度器调度的，
通过观察发现erts_timeofday_mtx是个瓶颈，我们来一起查看下erts_timeofday_mtx锁的使用情况。

27> calendar:now_to_universal_time(erlang:timestamp()).
{{2018,3,11},{9,4,31}}


 简单回顾一下垃圾回收的知识,垃圾回收器的本质实际上是改变存活数据结构构成图的连通性.堆对象在图中的存活性是由指针的可到达性定义的.程序可以操作三种位置的数据:寄存器 程序栈(局部变量 临时变量)
 全局变量.这些位置的变量有一部分保存了指向堆数据的引用,他们构成了应用程序的根(Root).对于用户程序动态分配的内存只能通过Root或者根发出的指针链访问,程序不应该访问其地址空间的随机位置.
   内存分配的解决方案有:
    [1] 静态分配 优点是:编译器知道所有的数据位置,实现效率高 缺点是:每一个数据结构的大小必须在编译时可知,方法调用不可以是递归的,因为同一个方法在内存中共享相同的位置. 无法动态创建数据结构
    [2] 栈分配 调用的时候入栈,调用结束出栈;同一个方法的不同调用不再共享地址,递归成为可能;只有大小能在编译时去递归大小的对象池啊能作为过程的结果返回.被调用者的生命周期不可能比调用方的生命周期更长.
    [3]堆分配 闭包成为可能 递归结构的表达式成为可能

   垃圾回收的经典算法有:引用计数 标记清除 节点复制
  [1] 引用计数方法是和程序执行同时进行,内存管理的开销比较均匀,这样进行没有长时间的挂起内存管理的时间比较稳定,可以获得比较平滑的响应时间;
  [2]标记清除 内存单元不会被立即回收,而是处于不可到达状态,直到所有的内存都被耗尽,进行全局级别的遍历来确定哪些单元可以回收.
  显然这种全局级别的中断在实时性要求较高的系统并不实用,甚至视频游戏都不可能接受在GC时有这么长的停顿.
  如果实时性方面要求不高,标记清除可以获得比引用计数更好的性能.标记清除的代价还是较高,标记是全局级别的,算法复杂度与整个堆大小成正比;
  标记清除使得内存空间倾向于碎片化.在物理存储器中碎片化的影响不大,但虚拟存储中会导致辅助存储器和主存之间频繁的交换页面,系统出现颠簸.
 [3]节点复制将堆分成两个半区,一个包含现有数据,另一个包含已经被废弃的数据,运行时两个半区的角色不断交换;这样做的优势在于内存分配的开销很小,只需要比较指针,不存在内存碎片的问题.但是内存浪费较大;
 [4]标记-整理缩并 标记所有的存活对象 通过重新调整存活对象位置来缩并对象图；更新指向被移动了位置的对象的指针
 [5] 分代回收 是基于统计学原理的:多数内存块的生存周期都比较短,垃圾收集器应当把更多的精力放在检查和清理新分配的内存块上

 IBM公司的David F.Bacon [7] 2004年发表了"A Unified Theory of Garbage Collection"论文,文中阐述了一种理论:任何一种GC算法都是跟踪回收和引用计数的两种回收思路的组合;

Erlang的垃圾回收是以进程为单位的,虽然GC过程会进程挂起但是由于回收速度快,影响很小.垃圾回收使用的是generational stop-and-copy回收器.从Erlang进程终止到其释放的内存被重用中间是没有延迟的.
由于GC回收是以进程为单位,垃圾回收器的一个不便之处就是不能跨进程处理进程堆.同样的,由于进程间数据独立没有数据共享,
消息发送实际上就是数据复制来实现的,如果复制的数据量很大也是会影响效率的,所以Erlang提倡的是小消息,大运算.








